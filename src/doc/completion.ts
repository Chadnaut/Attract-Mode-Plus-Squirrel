import { CompletionItem, CompletionItemKind, SnippetString } from "vscode";
import { AST } from "../ast";
import { getBranchClassDef, getBranchId, getNodeAfterPos } from "../utils/find";
import { getNodeParams } from "../utils/params";
import { getNodeReturn } from "../utils/return";
import { getNodeDisplayType } from "../utils/signature";
import { isNewSlotAssignment } from "../utils/root";
import { getNodeVal } from "../utils/definition";
import { getEnumType } from "../utils/enum";
import { getAttrByKind, getDocTargetBranch } from "./find";
import { ucfirst } from "../utils/string";
import { DocAttr, getKindOrder } from "./kind";
import { printDocAttrs } from "./print";
import constants from "../constants";
import * as path from "path";
import { createParamAttr } from "./attribute";
import { getConfigValue } from "../utils/config";
import { getImportAttrs } from "../utils/program";

/**
 * Return DocBlock completion at given pos
 * - If pos is at beginning of file, return a special program completion
 */
export const getDocCompletionsAtPos = (
    program: AST.Program,
    pos: AST.Position,
): CompletionItem[] => {
    const completions = getDocCompletions(getNodeAfterPos(program, pos));
    if (pos.index === 3) completions.push(...getDocProgramCompletions(program));
    if (completions.length) completions.at(-1).preselect = true;
    return completions;
};

// -----------------------------------------------------------------------------

/** Create program completion */
export const getDocProgramCompletions = (
    program: AST.Program,
): CompletionItem[] => {
    const pathName = path.basename(path.dirname(program.sourceName));
    const fileName = path.basename(program.sourceName, constants.LANGUAGE_EXTENSION);

    const title = `${ucfirst(pathName)} ${ucfirst(fileName)}`.replace(/^\W*/, "").trim() || "Untitled";
    const d = new Date();
    const year = d.getFullYear();
    const month = ('00' + (d.getMonth() + 1)).slice(-2);
    const date = ('00' + d.getDate()).slice(-2);
    const ts = `${year}-${month}-${date}`;
    const author = getConfigValue(constants.PACKAGE_AUTHOR);
    const url = getConfigValue(constants.PACKAGE_URL);

    const attrs: DocAttr[] = [
        { kind: "description", documentation: title },
        { kind: "summary", name: `A short description.` },
        { kind: "version", name: "0.0.1", documentation: ts },
        { kind: "author", name: author },
        { kind: "url", link: url },
    ];

    const importAttrs = getImportAttrs(program);
    if (importAttrs.length) {
        if (!getAttrByKind(attrs, "requires")) attrs.push({ kind: "requires" });
        attrs.push(...importAttrs);
    }

    attrs.sort((a, b) => getKindOrder(a.kind) - getKindOrder(b.kind));

    const text = printDocAttrs(attrs)
        .replace(/^( \* @(?:summary|requires))/gm, " *\n$1") // newline before
        .replace(
            /^( \* @(?:artwork|module).*?\n)( \* @(?!artwork|module))/m,
            "$1 *\n$2",
        ); // newline after last

    const snippet = new SnippetString();
    snippet.appendText(`\n${text} *\n * Additional instructions.\n`);

    const item = new CompletionItem(
        "/** Autogenerated Package */",
        CompletionItemKind.Snippet,
    );
    item.insertText = snippet;
    return [item];
};

// -----------------------------------------------------------------------------

/**
 * Return doc completion tailored to the target node
 */
export const getDocCompletions = (branch: AST.Node[]): CompletionItem[] => {
    const docBranch = getDocTargetBranch(branch);
    const nodeVal = getNodeVal(docBranch);
    const node = nodeVal.at(-1);

    const name = getBranchId(docBranch)?.name ?? "";
    const attrs: DocAttr[] = [];

    let description = "Description placeholder";
    let isConstructor = false;

    if (isNewSlotAssignment(branch)) {
        attrs.push({ kind: "global" });
    } else if (name.indexOf("__") === 0) {
        attrs.push({ kind: "private" });
    } else if (name.indexOf("_") === 0) {
        attrs.push({ kind: "protected" });
    }

    // Special attributes
    switch (node?.type) {
        case "EnumDeclaration":
            attrs.push({ kind: "enum", type: getEnumType(nodeVal) });
            break;
        case "MethodDefinition":
            isConstructor =
                (<AST.MethodDefinition>node).kind === "constructor";
            if (isConstructor) {
                const classDef = getBranchClassDef(nodeVal);
                const className = getBranchId(classDef)?.name ?? "class";
                description = `Creates an instance of ${className}.`;
                attrs.push({ kind: "constructor" });
            }
            break;
    }

    // Param attributes
    attrs.push(
        ...getNodeParams(nodeVal)
            .map((param) => createParamAttr(param))
            .filter((value) => value),
    );

    // Return attribute
    if (!isConstructor) {
        switch (node?.type) {
            case "MethodDefinition":
            case "FunctionDeclaration":
            case "FunctionExpression":
            case "LambdaExpression": {
                const returnName = getNodeDisplayType(getNodeReturn(nodeVal));
                if (returnName && returnName !== "null") {
                    attrs.push({ kind: "returns", type: returnName });
                }
                break;
            }
        }
    }

    // Join attributes
    const snippet = new SnippetString();
    if (attrs.length) {
        snippet.appendText("\n * ");
        snippet.appendPlaceholder(description);
        snippet.appendText("\n");
        snippet.appendText(printDocAttrs(attrs));
    } else {
        snippet.appendText(" ");
        snippet.appendPlaceholder(description);
    }

    const item = new CompletionItem(
        "/** Autogenerated Doc */",
        CompletionItemKind.Snippet,
    );
    item.insertText = snippet;
    return [item];
};
